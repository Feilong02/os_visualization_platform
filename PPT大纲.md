# 操作系统原理可视化实验展示平台 - PPT 大纲

## 封面页

- 题目：操作系统原理可视化实验展示平台
- 课程：操作系统
- 小组成员：XXX
- 日期：2025年X月

---

## 一、选题背景与实验目的（2页）

### 1.1 选题背景

**操作系统课程的重要性**
- 计算机专业核心基础课程
- 涵盖进程管理、内存管理、CPU调度等关键概念

**传统教学的痛点**
- 进程状态转换过程不直观，学生难以理解状态机模型
- 调度算法执行流程难以追踪，时间片轮转等概念抽象
- 内存分配与回收过程复杂，碎片产生机制不易观察
- 同步机制（信号量、死锁）理解困难，P/V操作逻辑抽象

**可视化教学的价值**
- 将抽象概念具象化，降低理解门槛
- 实时交互式演示，增强学习体验

### 1.2 实验目的

1. **理论理解**：通过可视化方式深入理解操作系统核心原理
2. **算法掌握**：掌握进程调度、内存管理等经典算法的实现
3. **工程实践**：提升 GUI 开发与软件工程实践能力
4. **综合应用**：将多线程编程、事件驱动等技术综合运用

---

## 二、系统总体架构与模块划分（2页）

### 2.1 技术选型

| 技术 | 选型 | 选型理由 |
|------|------|----------|
| 开发语言 | Python 3.9+ | 开发效率高，生态丰富 |
| GUI 框架 | PyQt5 | 跨平台，组件丰富，信号槽机制适合事件驱动 |
| 系统监控 | psutil | 跨平台获取系统进程/资源信息 |
| 数据结构 | dataclasses | 简化数据类定义 |
| 多线程 | threading | 实现动画与逻辑分离 |

### 2.2 系统架构（MVC 分层）

```
┌─────────────────────────────────────────────────────┐
│                    UI 层 (View)                      │
│  main_window.py + 各功能模块界面 (*_module.py)        │
├─────────────────────────────────────────────────────┤
│                可视化组件层 (View)                    │
│  state_machine / gantt_chart / memory_view / ...    │
├─────────────────────────────────────────────────────┤
│                  核心逻辑层 (Model)                   │
│  process / scheduler / memory / synchronization     │
└─────────────────────────────────────────────────────┘
```

### 2.3 模块划分

| 模块 | 核心功能 | 对应文件 |
|------|----------|----------|
| 进程管理 | 进程生命周期、状态转换、线程管理 | process.py, process_module.py |
| 进程通信 | 生产者-消费者模型、共享缓冲区 | ipc.py, ipc_module.py |
| 进程同步 | 哲学家就餐、信号量、死锁检测 | synchronization.py, sync_module.py |
| CPU 调度 | FCFS/RR/SJF/优先级 + 甘特图 | scheduler.py, scheduler_module.py |
| 内存管理 | 动态分配 + 页面置换算法 | memory.py, memory_module.py |
| 任务管理器 | 系统实时监控 | system_monitor.py, task_manager_module.py |

---

## 三、各模块的设计原理与实现方法（8-10页）

### 3.1 进程管理模块

**设计原理**
- 采用五状态模型：新建(New) → 就绪(Ready) → 运行(Running) → 阻塞(Blocked) → 终止(Terminated)
- 使用状态机模式实现状态转换逻辑
- 支持进程与线程两级管理

**核心算法**
```
状态转换规则：
- 创建进程 → New → Ready（加入就绪队列）
- 调度选中 → Ready → Running
- 时间片用完/主动让出 → Running → Ready
- 等待I/O → Running → Blocked
- I/O完成 → Blocked → Ready
- 执行完毕 → Running → Terminated
```

**实现方法**
- `Process` 类封装进程属性（PID、状态、优先级等）
- `ProcessManager` 管理进程队列与状态转换
- Qt 信号槽实现 UI 与逻辑解耦

**可视化展示**
- 状态机图：圆形节点表示状态，箭头表示转换
- 就绪/阻塞队列动态更新
- 状态转换动画效果

【截图位置：进程状态转换界面】

---

### 3.2 进程通信模块

**设计原理**
- 经典生产者-消费者问题
- 有界缓冲区实现共享内存通信
- 信号量实现同步互斥

**核心算法**
```
生产者：
    P(empty)        # 等待空槽位
    P(mutex)        # 互斥访问缓冲区
    放入产品
    V(mutex)
    V(full)         # 通知消费者

消费者：
    P(full)         # 等待产品
    P(mutex)
    取出产品
    V(mutex)
    V(empty)        # 通知生产者
```

**实现方法**
- `SharedBuffer` 类实现环形缓冲区
- `Producer`/`Consumer` 类继承自线程
- 支持动态调节生产/消费速率

**可视化展示**
- 缓冲区格子动态填充/消费动画
- 生产者/消费者状态指示
- 实时事件日志

【截图位置：生产者-消费者界面】

---

### 3.3 进程同步模块

**设计原理**
- 哲学家就餐问题（Dining Philosophers）
- 信号量 P/V 操作实现同步
- 死锁预防策略

**核心算法**
```
哲学家 i 的行为：
    思考()
    拿起左边叉子 P(fork[i])
    拿起右边叉子 P(fork[(i+1)%5])
    进餐()
    放下右边叉子 V(fork[(i+1)%5])
    放下左边叉子 V(fork[i])

死锁预防（奇偶策略）：
    奇数号哲学家：先拿左叉，后拿右叉
    偶数号哲学家：先拿右叉，后拿左叉
```

**实现方法**
- `Philosopher` 类模拟哲学家行为
- `Semaphore` 类实现信号量
- 死锁检测算法检测资源循环等待

**可视化展示**
- 圆桌动画：5位哲学家 + 5把叉子
- 哲学家状态颜色区分（思考/饥饿/进餐）
- 叉子状态实时显示
- 信号量值面板
- 死锁检测警告提示

【截图位置：哲学家就餐界面】

---

### 3.4 CPU 调度模块

**设计原理**
- 实现4种经典调度算法
- 甘特图展示调度过程
- 性能指标对比分析

**核心算法**

| 算法 | 原理 | 特点 |
|------|------|------|
| FCFS | 按到达顺序调度 | 简单，但可能导致"护航效应" |
| RR | 时间片轮转 | 公平，响应时间短 |
| SJF | 选择剩余时间最短的进程 | 平均等待时间最优 |
| Priority | 按优先级调度 | 可能导致饥饿 |

```
时间片轮转算法伪代码：
while (就绪队列非空):
    取出队首进程 P
    执行 min(时间片, P剩余时间)
    if P剩余时间 > 0:
        P 重新入队
    else:
        P 完成
```

**实现方法**
- `Scheduler` 类封装调度逻辑
- 支持参数配置（时间片大小、优先级设置）
- 自动计算性能指标

**可视化展示**
- 甘特图动态绘制调度过程
- 进程颜色编码
- 性能指标面板：
  - 平均等待时间
  - 平均周转时间
  - CPU 利用率

【截图位置：CPU调度甘特图界面】

---

### 3.5 内存管理模块

#### 3.5.1 动态内存分配

**设计原理**
- 连续内存分配策略
- 4种适应算法对比

**核心算法**

| 算法 | 原理 | 优缺点 |
|------|------|--------|
| 首次适应 | 从头找第一个满足的空闲块 | 简单，但前端碎片多 |
| 最佳适应 | 找最小满足的空闲块 | 碎片小，但查找慢 |
| 最坏适应 | 找最大的空闲块 | 减少小碎片，但大块消耗快 |
| 循环首次适应 | 从上次位置继续查找 | 分布均匀 |

**可视化展示**
- 内存块颜色编码（已分配/空闲）
- 碎片率实时统计
- 分配/释放动画

【截图位置：内存分配界面】

#### 3.5.2 页面置换

**设计原理**
- 虚拟内存页面置换
- 4种置换算法实现

**核心算法**

| 算法 | 原理 | 特点 |
|------|------|------|
| FIFO | 淘汰最先进入的页面 | 简单，可能Belady异常 |
| LRU | 淘汰最近最少使用的页面 | 性能好，实现复杂 |
| OPT | 淘汰未来最长时间不用的页面 | 最优，但不可实现（用于对比） |
| CLOCK | 时钟指针扫描，淘汰访问位为0的页面 | 近似LRU，开销小 |

**可视化展示**
- 页框状态表格
- 页面访问序列展示
- 缺页/命中动画提示
- 缺页率统计图表

【截图位置：页面置换界面】

---

### 3.6 任务管理器模块

**设计原理**
- 使用 psutil 获取系统真实数据
- 后台线程定时采集，避免UI阻塞
- 数据可视化展示

**实现方法**
- `SystemMonitor` 类封装系统信息采集
- 定时器周期刷新（默认1秒）
- 支持进程排序与筛选

**可视化展示**
- CPU 使用率实时曲线
- 内存使用率环形图
- 每核心 CPU 独立显示
- 系统进程列表（PID、名称、CPU%、内存%）
- 支持按不同字段排序

【截图位置：任务管理器界面】

---

## 四、功能展示与运行结果（3-4页）

### 4.1 系统主界面

- Tab 页切换6大功能模块
- 统一的界面风格
- 响应式布局设计

【截图：主界面全貌】

### 4.2 核心功能演示

**演示1：进程状态转换**
- 创建进程 → 观察状态机动画
- 触发阻塞 → 观察队列变化
- 恢复执行 → 完整生命周期展示

**演示2：哲学家就餐与死锁检测**
- 启动5位哲学家
- 观察正常就餐过程
- 触发死锁场景，展示检测与恢复

**演示3：CPU 调度算法对比**
- 输入相同进程集
- 分别执行FCFS、RR、SJF、Priority
- 对比甘特图与性能指标

**演示4：页面置换算法对比**
- 输入页面访问序列
- 演示FIFO、LRU、OPT、CLOCK
- 对比缺页率

### 4.3 运行结果数据

| 测试场景 | 测试内容 | 结果 |
|----------|----------|------|
| 进程管理 | 状态转换完整性 | 5种状态正确切换 |
| 进程同步 | 死锁检测准确性 | 100%检测成功 |
| CPU调度 | 性能指标计算 | 与理论值一致 |
| 页面置换 | 缺页率统计 | OPT < LRU < CLOCK < FIFO |

---

## 五、小组分工与项目管理（1-2页）

### 5.1 小组成员与分工

| 成员 | 负责模块 | 主要工作 |
|------|----------|----------|
| 成员A | 进程管理、进程通信 | 核心逻辑 + UI界面 |
| 成员B | CPU调度、内存管理 | 算法实现 + 可视化 |
| 成员C | 进程同步、任务管理器 | 动画效果 + 系统集成 |
| 成员D | 整体架构、文档 | 架构设计 + PPT制作 |

### 5.2 版本控制方式

**版本控制工具**：Git

**分支管理策略**：
```
main        ─────●─────●─────●───── 稳定版本
              ↑      ↑      ↑
feature/*  ──●──●   ●──●   ●──●   功能开发
```

**协作流程**：
1. 每个功能模块创建独立分支（feature/xxx）
2. 完成开发后提交 Pull Request
3. 代码审查通过后合并到 main 分支
4. 使用 Issue 跟踪任务与Bug

**版本里程碑**：
- v1.0：基础4模块完成（进程、通信、同步、调度）
- v2.0：新增内存管理模块
- v2.2：新增任务管理器模块

---

## 六、问题与改进方向（1-2页）

### 6.1 遇到的问题与解决方案

| 问题 | 原因分析 | 解决方案 |
|------|----------|----------|
| 多线程UI更新崩溃 | 非主线程直接操作UI | 使用Qt信号槽机制跨线程通信 |
| 任务管理器卡顿 | 主线程获取进程列表耗时 | 后台线程采集 + 定时器刷新 |
| 动画不流畅 | 重绘频率过高 | 使用QTimer控制帧率 |
| 哲学家死锁检测不准确 | 资源图分析逻辑错误 | 实现完整的环检测算法 |

### 6.2 项目不足

- 界面美观度有待提升
- 部分算法参数不支持自定义
- 缺少数据导入/导出功能
- 未实现算法执行的单步调试

### 6.3 改进方向

**功能扩展**
- 添加更多调度算法（多级反馈队列等）
- 支持自定义参数导入/导出（JSON格式）
- 增加算法执行的单步/暂停/回放功能

**技术优化**
- 引入 QML 提升界面美观度
- 使用数据库存储实验数据
- 添加算法性能对比报告生成

**教学增强**
- 添加原理说明弹窗
- 支持自定义实验场景
- 增加算法伪代码同步高亮显示

---

## 七、总结（1页）

### 7.1 项目成果

- 成功实现 **6大功能模块**，涵盖操作系统核心概念
- 实现 **12种算法** 的可视化演示
- 完成 **实时系统监控** 功能
- 项目代码结构清晰，采用MVC分层架构

### 7.2 学习收获

- 深入理解操作系统进程管理、内存管理等核心原理
- 掌握 PyQt5 GUI 开发与多线程编程
- 提升软件工程实践能力（版本控制、模块化设计）
- 体会可视化对理解抽象概念的帮助

---

## 八、现场演示（5-8分钟）

### 演示内容

1. **启动程序**：展示主界面布局
2. **进程管理**：创建进程，演示状态转换
3. **进程同步**：启动哲学家就餐，展示死锁检测
4. **CPU调度**：输入进程，对比不同算法甘特图
5. **页面置换**：输入页面序列，演示置换过程
6. **任务管理器**：展示实时系统监控数据

---

## 致谢页

感谢老师的指导！

欢迎提问！

---

## PPT 制作建议

1. **配色方案**：蓝色系为主，保持专业感
2. **字体大小**：标题 32pt，正文 24pt，代码 18pt
3. **截图处理**：统一大小，添加边框阴影
4. **动画使用**：适度使用，避免过于花哨
5. **代码展示**：使用等宽字体，语法高亮

## 预计页数

- 总页数：20-25 页
- 时间分配：
  - 背景与目的：2 分钟
  - 架构设计：2 分钟
  - 模块实现：5 分钟
  - 功能演示：6 分钟
  - 分工与问题：2 分钟
  - 总结答疑：3 分钟
