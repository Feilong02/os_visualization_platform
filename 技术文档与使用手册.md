# 操作系统原理可视化实验展示平台 - 技术文档与使用手册

> 版本：v2.2.0 | 更新日期：2025年

---

## 目录

- [一、技术架构](#一技术架构)
- [二、项目结构](#二项目结构)
- [三、核心算法实现](#三核心算法实现)
- [四、使用手册](#四使用手册)
- [五、API 参考](#五api-参考)
- [六、常见问题](#六常见问题)

---

## 一、技术架构

### 1.1 技术选型

| 技术 | 版本 | 用途 | 选型理由 |
|------|------|------|----------|
| Python | 3.8+ | 主要开发语言 | 开发效率高，生态丰富 |
| PyQt5 | 5.15.x | GUI 图形界面框架 | 跨平台，组件丰富，信号槽机制适合事件驱动 |
| psutil | 5.9.x | 系统监控 | 跨平台获取 CPU、内存、进程信息 |
| threading | 内置 | 多线程支持 | Python 标准库，无需额外安装 |
| dataclasses | 内置 | 数据类定义 | 简化数据结构定义 |

### 1.2 架构模式

采用 **MVC 分层架构**，实现逻辑与界面分离：

```
┌─────────────────────────────────────────────────────────────┐
│                      UI 层 (Controller)                      │
│        main_window.py + 各功能模块界面 (*_module.py)          │
│                    负责界面交互和业务协调                      │
├─────────────────────────────────────────────────────────────┤
│                    可视化组件层 (View)                        │
│     state_machine / gantt_chart / memory_view / ...         │
│                    负责可视化绘制与动画                       │
├─────────────────────────────────────────────────────────────┤
│                     核心逻辑层 (Model)                        │
│       process / scheduler / memory / synchronization        │
│                    负责算法逻辑与数据处理                     │
└─────────────────────────────────────────────────────────────┘
```

**分层职责：**

| 层级 | 目录 | 职责 |
|------|------|------|
| Model | `core/` | 算法实现、数据结构、业务逻辑 |
| View | `visualization/` | 图形绘制、动画效果、可视化组件 |
| Controller | `ui/` | 用户交互、事件处理、业务协调 |

### 1.3 数据流向

```
┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│ 用户操作  │───▶│ UI层接收  │───▶│ Core层   │───▶│ 返回结果  │───▶│ 更新View │
│          │    │   事件    │    │ 算法计算  │    │          │    │ 界面刷新  │
└──────────┘    └──────────┘    └──────────┘    └──────────┘    └──────────┘
```

### 1.4 线程模型

```
┌─────────────────────────────────────────────────────────────┐
│                        主线程 (UI线程)                       │
│              PyQt5 事件循环，处理用户交互                      │
├─────────────────────────────────────────────────────────────┤
│                        工作线程                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │ 哲学家线程    │  │ 生产者线程   │  │ 系统监控线程  │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    Qt 信号槽机制 (线程安全)
```

---

## 二、项目结构

### 2.1 目录结构

```
os_visualization_platform/
│
├── main.py                      # 程序入口
├── requirements.txt             # 项目依赖
├── README.md                    # 项目说明
├── 技术文档与使用手册.md          # 本文档
├── PPT大纲.md                   # 展示 PPT 大纲
│
├── core/                        # 核心逻辑层
│   ├── __init__.py              # 模块初始化
│   ├── process.py               # 进程与线程数据结构及管理
│   ├── scheduler.py             # CPU调度算法（FCFS/RR/SJF/Priority）
│   ├── synchronization.py       # 信号量和哲学家就餐问题
│   ├── ipc.py                   # 进程间通信（生产者-消费者）
│   ├── memory.py                # 内存管理算法（分配+页面置换）
│   └── system_monitor.py        # 系统监控（获取真实系统数据）
│
├── ui/                          # 界面控制层
│   ├── __init__.py              # 模块初始化
│   ├── main_window.py           # 主窗口，管理所有标签页
│   ├── process_module.py        # 模块1：进程管理界面
│   ├── ipc_module.py            # 模块2：进程通信界面
│   ├── sync_module.py           # 模块3：进程同步界面
│   ├── scheduler_module.py      # 模块4：CPU调度界面
│   ├── memory_module.py         # 模块5：内存管理界面
│   └── task_manager_module.py   # 模块6：任务管理器界面
│
└── visualization/               # 可视化层
    ├── __init__.py              # 模块初始化
    ├── state_machine.py         # 进程状态机动画
    ├── gantt_chart.py           # 甘特图组件
    ├── queue_animation.py       # 队列动画
    ├── philosopher_table.py     # 哲学家餐桌动画
    ├── buffer_animation.py      # 缓冲区动画
    └── memory_view.py           # 内存块和页框可视化
```

### 2.2 模块依赖关系

```
                    ┌─────────────────┐
                    │    main.py      │
                    └────────┬────────┘
                             │
                    ┌────────▼────────┐
                    │   MainWindow    │
                    └────────┬────────┘
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
        ▼                    ▼                    ▼
┌───────────────┐  ┌───────────────┐  ┌───────────────┐
│  UI Modules   │──│ Visualization │──│    Core       │
│  (界面模块)    │  │  (可视化组件)  │  │  (核心算法)   │
└───────────────┘  └───────────────┘  └───────────────┘
```

### 2.3 文件说明

| 文件 | 代码行数(约) | 主要功能 |
|------|-------------|----------|
| `core/process.py` | 200+ | Process/Thread 类定义，ProcessManager |
| `core/scheduler.py` | 300+ | 4种调度算法实现 |
| `core/memory.py` | 400+ | 内存分配 + 页面置换算法 |
| `core/synchronization.py` | 250+ | Semaphore，Philosopher，死锁检测 |
| `core/ipc.py` | 200+ | SharedBuffer，Producer，Consumer |
| `visualization/gantt_chart.py` | 200+ | 甘特图 QPainter 绘制 |
| `visualization/philosopher_table.py` | 300+ | 圆桌动画 |

---

## 三、核心算法实现

### 3.1 进程状态机

**五状态模型：**

```
        ┌─────────────────────────────────────┐
        │                                     │
        ▼                                     │
    ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
    │ 创建 │───▶│ 就绪 │◀──▶│ 运行 │───▶│ 终止 │
    └──────┘    └──────┘    └──────┘    └──────┘
                    ▲           │
                    │           ▼
                    │      ┌──────┐
                    └──────│ 阻塞 │
                           └──────┘
```

**状态转换规则：**

| 当前状态 | 可转换到 | 触发条件 |
|----------|----------|----------|
| 创建 (New) | 就绪、终止 | 进程创建完成 / 创建失败 |
| 就绪 (Ready) | 运行、终止 | 被调度选中 / 被终止 |
| 运行 (Running) | 就绪、阻塞、终止 | 时间片用完 / 等待I/O / 执行完毕 |
| 阻塞 (Blocked) | 就绪、终止 | I/O完成 / 被终止 |
| 终止 (Terminated) | - | 最终状态 |

**代码实现要点：**

```python
class ProcessState(Enum):
    NEW = "新建"
    READY = "就绪"
    RUNNING = "运行"
    BLOCKED = "阻塞"
    TERMINATED = "终止"

# 状态转换矩阵
VALID_TRANSITIONS = {
    ProcessState.NEW: [ProcessState.READY, ProcessState.TERMINATED],
    ProcessState.READY: [ProcessState.RUNNING, ProcessState.TERMINATED],
    ProcessState.RUNNING: [ProcessState.READY, ProcessState.BLOCKED, ProcessState.TERMINATED],
    ProcessState.BLOCKED: [ProcessState.READY, ProcessState.TERMINATED],
    ProcessState.TERMINATED: []
}
```

### 3.2 CPU 调度算法

#### FCFS（先来先服务）

```
算法：按进程到达时间顺序执行，不可抢占
时间复杂度：O(n)
优点：简单公平
缺点：可能导致"护航效应"（短作业等待长作业）

伪代码：
  按到达时间排序
  依次执行每个进程直到完成
```

#### RR（时间片轮转）

```
算法：每个进程执行固定时间片，未完成则放入队尾
时间复杂度：O(n)
优点：响应时间短，公平
缺点：时间片选择影响性能

伪代码：
  while 就绪队列非空:
      取出队首进程 P
      执行 min(时间片, P剩余时间)
      if P剩余时间 > 0:
          P 重新入队
      else:
          P 完成
```

#### SJF（最短作业优先）

```
算法：每次选择剩余执行时间最短的进程执行
时间复杂度：O(n log n)（使用优先队列）
优点：平均等待时间最优
缺点：可能导致长作业饥饿

伪代码：
  while 有未完成进程:
      从已到达进程中选择剩余时间最短的
      执行该进程
```

#### Priority（优先级调度）

```
算法：每次选择优先级最高（数值最小）的进程执行
时间复杂度：O(n log n)
优点：灵活，可体现任务重要性
缺点：低优先级可能饥饿

伪代码：
  while 有未完成进程:
      从已到达进程中选择优先级最高的
      执行该进程
```

**性能指标计算：**

| 指标 | 公式 |
|------|------|
| 等待时间 | 开始时间 - 到达时间 |
| 周转时间 | 完成时间 - 到达时间 |
| 平均等待时间 | Σ等待时间 / 进程数 |
| 平均周转时间 | Σ周转时间 / 进程数 |

### 3.3 内存分配算法

| 算法 | 策略 | 优点 | 缺点 |
|------|------|------|------|
| 首次适应 (First Fit) | 从头查找第一个足够大的空闲块 | 简单快速 | 前端碎片多 |
| 最佳适应 (Best Fit) | 查找最小的足够大的空闲块 | 碎片小 | 查找慢，产生很小碎片 |
| 最坏适应 (Worst Fit) | 查找最大的空闲块 | 减少小碎片 | 大块消耗快 |
| 循环首次适应 (Next Fit) | 从上次位置继续查找 | 分布均匀 | 可能绕过合适块 |

**内存块数据结构：**

```python
@dataclass
class MemoryBlock:
    start: int      # 起始地址
    size: int       # 块大小
    process: str    # 所属进程（None表示空闲）
    is_free: bool   # 是否空闲
```

### 3.4 页面置换算法

| 算法 | 策略 | 缺页率 | 实现复杂度 |
|------|------|--------|-----------|
| FIFO | 淘汰最先进入内存的页面 | 较高 | O(1) |
| LRU | 淘汰最长时间未被访问的页面 | 较低 | O(n) |
| OPT | 淘汰未来最长时间不会被访问的页面 | 最低 | O(n) |
| CLOCK | 使用引用位的近似 LRU | 接近LRU | O(n) |

**CLOCK 算法实现：**

```python
def clock_replace(frames, reference_bits, pointer):
    while True:
        if reference_bits[pointer] == 0:
            victim = pointer
            pointer = (pointer + 1) % len(frames)
            return victim
        reference_bits[pointer] = 0
        pointer = (pointer + 1) % len(frames)
```

### 3.5 信号量机制

**P 操作（wait/申请资源）：**

```python
def P(semaphore):
    semaphore.value -= 1
    if semaphore.value < 0:
        # 进程阻塞，加入等待队列
        block(current_process)
```

**V 操作（signal/释放资源）：**

```python
def V(semaphore):
    semaphore.value += 1
    if semaphore.value <= 0:
        # 唤醒等待队列中的一个进程
        wakeup(semaphore.waiting_queue.pop())
```

### 3.6 死锁预防

**哲学家就餐问题的死锁预防策略：**

```
问题：5位哲学家，5把叉子，每人需要两把叉子才能进餐

死锁条件（循环等待）：
  所有哲学家同时拿起左边叉子
  → 每人都在等待右边叉子
  → 形成循环等待

预防策略（奇偶策略）：
  偶数号哲学家：先拿左叉，后拿右叉
  奇数号哲学家：先拿右叉，后拿左叉
  → 打破循环等待
```

**死锁检测算法：**

```python
def detect_deadlock(philosophers, forks):
    """检测资源分配图中是否存在环"""
    # 构建等待图
    wait_graph = build_wait_graph(philosophers, forks)
    # DFS 检测环
    return has_cycle(wait_graph)
```

---

## 四、使用手册

### 4.1 启动程序

```bash
# 安装依赖
pip install -r requirements.txt

# 运行程序
python main.py
```

### 4.2 模块1：进程管理

**界面布局：**
- 左侧：进程控制面板（创建、状态转换按钮）
- 中间：进程/线程列表
- 右侧：状态机图 + 队列视图

**操作步骤：**

1. **创建进程**
   - 在左侧面板输入进程名称
   - 点击"创建进程"按钮
   - 进程自动进入"就绪"状态

2. **状态转换**
   - 选择列表中的进程
   - 点击对应的状态转换按钮
   - 观察状态机图动画

3. **创建线程**
   - 先选择一个进程
   - 点击"创建线程"
   - 线程显示在父进程下

**状态颜色说明：**

| 状态 | 颜色 |
|------|------|
| 新建 | 灰色 |
| 就绪 | 蓝色 |
| 运行 | 绿色 |
| 阻塞 | 橙色 |
| 终止 | 红色 |

### 4.3 模块2：进程通信

**操作步骤：**

1. 设置缓冲区容量（默认 5）
2. 点击"添加生产者"/"添加消费者"
3. 使用滑块调整生产/消费速率
4. 点击"开始"观察运行
5. 查看事件日志了解详细过程

**可视化说明：**
- 缓冲区格子：填充表示有数据
- 生产者箭头：指向缓冲区
- 消费者箭头：从缓冲区指出

### 4.4 模块3：进程同步

**操作步骤：**

1. 选择是否启用"死锁预防"
2. 调整"思考时间"和"进餐时间"滑块
3. 点击"开始模拟"
4. 观察哲学家状态变化

**死锁演示方法：**

1. **关闭**死锁预防
2. 将思考时间和进餐时间都调到最小（如 0.5 秒）
3. 点击开始
4. 等待 10-30 秒，系统会检测到死锁并显示警告

**状态颜色说明：**

| 状态 | 哲学家颜色 | 信号量颜色 |
|------|-----------|-----------|
| 思考 | 蓝色 | - |
| 饥饿 | 黄色 | - |
| 进餐 | 绿色 | - |
| 叉子可用 (>0) | - | 绿色 |
| 叉子被占用 (=0) | - | 黄色 |
| 有等待者 (<0) | - | 红色 |

### 4.5 模块4：CPU 调度

**操作步骤：**

1. **添加进程**
   - 输入进程名称
   - 设置到达时间、执行时间、优先级
   - 点击"添加"

2. **选择算法**
   - 从下拉框选择调度算法
   - RR 算法需要设置时间片大小

3. **执行调度**
   - 点击"执行调度"：立即显示结果
   - 点击"动画演示"：逐步动画展示

4. **查看结果**
   - 甘特图显示调度顺序
   - 下方表格显示各进程详细指标
   - 性能指标显示平均等待/周转时间

**进程颜色：** 系统自动分配不同颜色

### 4.6 模块5：内存管理

#### 动态内存分配

**操作步骤：**

1. 设置总内存大小（默认 1024 KB）
2. 点击"初始化内存"
3. 输入进程名和请求大小
4. 选择分配算法
5. 点击"分配"
6. 选择进程后点击"释放"可释放内存

**内存视图颜色：**
- 灰色：空闲块
- 彩色：已分配块（不同进程不同颜色）

#### 页面置换

**操作步骤：**

1. 设置页框数量（如 3）
2. 输入页面访问序列（如：`7,0,1,2,0,3,0,4`）
3. 选择置换算法
4. 点击"执行"或"动画演示"

**结果说明：**
- **H**：命中（Hit，页面在内存中）
- **M**：缺失（Miss，发生缺页）
- 缺页率 = 缺页次数 / 总访问次数 × 100%

### 4.7 模块6：任务管理器

**功能说明：**
- 自动实时刷新系统信息
- CPU 使用率曲线图
- 内存使用率环形图
- 各 CPU 核心独立显示
- 进程列表支持排序

**排序方式：**
- 按 CPU 使用率
- 按内存使用率
- 按 PID
- 按进程名称

**刷新间隔：** 500ms - 5000ms 可调

---

## 五、API 参考

### 5.1 核心类

#### Process 类

```python
class Process:
    pid: int                    # 进程ID
    name: str                   # 进程名称
    state: ProcessState         # 当前状态
    priority: int               # 优先级
    arrival_time: float         # 到达时间
    burst_time: float           # 执行时间
    threads: List[Thread]       # 线程列表
```

#### Scheduler 类

```python
class Scheduler:
    def fcfs(processes) -> List[ScheduleRecord]
    def round_robin(processes, time_quantum) -> List[ScheduleRecord]
    def sjf(processes) -> List[ScheduleRecord]
    def priority(processes) -> List[ScheduleRecord]
```

#### MemoryManager 类

```python
class MemoryManager:
    def allocate(process_name, size, algorithm) -> bool
    def deallocate(process_name) -> bool
    def get_fragmentation() -> float
```

### 5.2 信号与槽

| 信号 | 参数 | 说明 |
|------|------|------|
| `process_created` | Process | 进程创建时发射 |
| `state_changed` | Process, old_state, new_state | 状态变化时发射 |
| `schedule_step` | time, process | 调度每一步发射 |
| `deadlock_detected` | List[Philosopher] | 检测到死锁时发射 |

---

## 六、常见问题

### Q1: 程序启动报错 "No module named 'PyQt5'"

**解决方法：**

```bash
pip install PyQt5
```

如果安装失败，尝试：

```bash
pip install PyQt5 -i https://pypi.tuna.tsinghua.edu.cn/simple
```

### Q2: 任务管理器显示"模拟数据"

**原因：** psutil 未安装或导入失败

**解决方法：**

```bash
pip install psutil
```

### Q3: 界面显示不完整或字体异常

**解决方法：**
1. 确保显示器缩放比例为 100%
2. 尝试调整窗口大小
3. 检查系统字体设置

### Q4: 哲学家问题无法触发死锁

**解决方法：**
1. 确保**关闭**了死锁预防选项
2. 将思考时间和进餐时间都调到最小
3. 多等待一段时间（通常 10-60 秒）
4. 死锁是概率事件，多次尝试

### Q5: 如何验证调度算法结果？

**手工验证步骤：**

1. 画出甘特图
2. 计算每个进程的开始时间、完成时间
3. 等待时间 = 开始时间 - 到达时间
4. 周转时间 = 完成时间 - 到达时间
5. 与程序结果对比

### Q6: 页面置换算法缺页率对比

典型情况下的缺页率排序：

```
OPT < LRU ≈ CLOCK < FIFO
```

OPT 是理论最优（需要预知未来），实际系统通常使用 LRU 或 CLOCK。

### Q7: 程序运行卡顿

**可能原因及解决：**
1. 动画帧率过高 → 降低刷新频率
2. 进程数过多 → 减少进程数量
3. 系统资源不足 → 关闭其他程序

---

## 附录

### A. 快捷键

| 快捷键 | 功能 |
|--------|------|
| Ctrl+1~6 | 切换到对应模块 |
| Space | 暂停/继续动画 |
| R | 重置当前模块 |

### B. 性能指标公式汇总

| 指标 | 公式 |
|------|------|
| 等待时间 | 开始时间 - 到达时间 |
| 周转时间 | 完成时间 - 到达时间 |
| CPU 利用率 | 有效执行时间 / 总时间 × 100% |
| 缺页率 | 缺页次数 / 总访问次数 × 100% |
| 命中率 | 命中次数 / 总访问次数 × 100% |
| 内存利用率 | 已分配内存 / 总内存 × 100% |
| 碎片率 | 碎片大小 / 空闲内存 × 100% |

### C. 参考资料

- 《操作系统概念》(Operating System Concepts) - Silberschatz
- 《现代操作系统》(Modern Operating Systems) - Tanenbaum
- PyQt5 官方文档: https://www.riverbankcomputing.com/static/Docs/PyQt5/

---

*文档版本：v2.2.0*
