# 操作系统原理可视化实验展示平台 - 技术文档与使用手册

## 目录

1. [技术架构](#一技术架构)
2. [项目结构](#二项目结构)
3. [核心算法实现](#三核心算法实现)
4. [使用手册](#四使用手册)
5. [常见问题](#五常见问题)

---

## 一、技术架构

### 1.1 技术选型

| 技术 | 版本 | 用途 |
|------|------|------|
| Python | 3.8+ | 主要开发语言 |
| PyQt5 | 5.15.x | GUI 图形界面框架 |
| psutil | 5.9.x | 系统监控（获取 CPU、内存、进程信息） |
| threading | 内置 | 多线程支持 |

### 1.2 架构模式

采用 MVC 分层架构：

- **Model（模型层）**：`core/` 目录，负责算法逻辑
- **View（视图层）**：`visualization/` 目录，负责可视化绘制
- **Controller（控制层）**：`ui/` 目录，负责界面交互和业务协调

### 1.3 数据流向

```
用户操作 → UI层接收事件 → 调用core层算法 → 返回计算结果 → 更新visualization层 → 界面刷新
```

---

## 二、项目结构

### 2.1 目录结构

```
os_visualization_platform/
│
├── main.py                      # 程序入口
│
├── core/                        # 核心逻辑层
│   ├── process.py              # 进程与线程数据结构及管理
│   ├── scheduler.py            # CPU调度算法（FCFS/RR/SJF/Priority）
│   ├── synchronization.py      # 信号量和哲学家就餐问题
│   ├── ipc.py                  # 进程间通信（生产者-消费者）
│   ├── memory.py               # 内存管理算法（分配+页面置换）
│   └── system_monitor.py       # 系统监控（获取真实系统数据）
│
├── ui/                          # 界面控制层
│   ├── main_window.py          # 主窗口，管理所有标签页
│   ├── process_module.py       # 模块1：进程管理界面
│   ├── ipc_module.py           # 模块2：进程通信界面
│   ├── sync_module.py          # 模块3：进程同步界面
│   ├── scheduler_module.py     # 模块4：CPU调度界面
│   ├── memory_module.py        # 模块5：内存管理界面
│   └── task_manager_module.py  # 模块6：任务管理器界面
│
└── visualization/               # 可视化层
    ├── state_machine.py        # 进程状态机动画
    ├── gantt_chart.py          # 甘特图组件
    ├── queue_animation.py      # 队列动画
    ├── philosopher_table.py    # 哲学家餐桌动画
    ├── buffer_animation.py     # 缓冲区动画
    └── memory_view.py          # 内存块和页框可视化
```

### 2.2 模块依赖关系

```
                    ┌─────────────────┐
                    │    main.py      │
                    └────────┬────────┘
                             │
                    ┌────────▼────────┐
                    │   MainWindow    │
                    └────────┬────────┘
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
        ▼                    ▼                    ▼
┌───────────────┐  ┌───────────────┐  ┌───────────────┐
│ UI Modules    │  │ Visualization │  │    Core       │
│ (界面模块)     │  │ (可视化组件)   │  │ (核心算法)    │
└───────────────┘  └───────────────┘  └───────────────┘
```

---

## 三、核心算法实现

### 3.1 进程状态机

**五状态模型：**

```
        ┌─────────────────────────────────────┐
        │                                     │
        ▼                                     │
    ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
    │ 创建 │───▶│ 就绪 │◀──▶│ 运行 │───▶│ 终止 │
    └──────┘    └──────┘    └──────┘    └──────┘
                    ▲           │
                    │           ▼
                    │      ┌──────┐
                    └──────│ 阻塞 │
                           └──────┘
```

**状态转换规则：**

| 当前状态 | 可转换到 |
|----------|----------|
| 创建 | 就绪、终止 |
| 就绪 | 运行、终止 |
| 运行 | 就绪、阻塞、终止 |
| 阻塞 | 就绪、终止 |
| 终止 | - |

### 3.2 CPU 调度算法

#### FCFS（先来先服务）

按进程到达时间顺序执行，不可抢占。

#### RR（时间片轮转）

每个进程执行固定时间片，未完成则放入队尾等待。

#### SJF（最短作业优先）

每次选择剩余执行时间最短的进程执行。

#### Priority（优先级调度）

每次选择优先级最高（数值最小）的进程执行。

### 3.3 内存分配算法

| 算法 | 策略 |
|------|------|
| 首次适应 | 从头查找第一个足够大的空闲块 |
| 最佳适应 | 查找最小的足够大的空闲块 |
| 最坏适应 | 查找最大的空闲块 |
| 循环首次适应 | 从上次位置继续查找 |

### 3.4 页面置换算法

| 算法 | 策略 |
|------|------|
| FIFO | 淘汰最先进入内存的页面 |
| LRU | 淘汰最长时间未被访问的页面 |
| OPT | 淘汰未来最长时间不会被访问的页面 |
| CLOCK | 使用引用位的近似 LRU 算法 |

### 3.5 信号量机制

**P 操作（wait/申请资源）：**
```
value = value - 1
if value < 0:
    进程阻塞，加入等待队列
```

**V 操作（signal/释放资源）：**
```
value = value + 1
if value <= 0:
    唤醒等待队列中的一个进程
```

### 3.6 死锁预防

哲学家就餐问题的死锁预防策略：打破循环等待条件。

- 关闭死锁预防时：所有哲学家都是先左后右拿叉子，形成循环
- 开启死锁预防时：最后一位哲学家先右后左，打破循环

---

## 四、使用手册

### 4.1 模块1：进程管理

**操作步骤：**
1. 在左侧面板输入进程名称
2. 点击"创建"按钮创建进程
3. 选择进程后可进行状态转换操作
4. 右侧可查看状态机图和队列变化

**功能说明：**
- 支持创建线程（在进程下创建）
- 状态转换自动验证合法性
- 队列实时更新

### 4.2 模块2：进程通信

**操作步骤：**
1. 设置缓冲区容量
2. 添加生产者和消费者
3. 调整生产/消费速率
4. 点击"开始"观察运行

**生产者-消费者模型：**
- 生产者：向缓冲区添加数据
- 消费者：从缓冲区取出数据
- 缓冲区满时生产者等待
- 缓冲区空时消费者等待

### 4.3 模块3：进程同步

**操作步骤：**
1. 选择是否启用死锁预防
2. 调整思考和进餐时间
3. 点击"开始"观察哲学家就餐

**死锁演示：**
1. 关闭死锁预防
2. 将思考时间和进餐时间调低（如 0.5 秒）
3. 观察运行，通常在 10-30 秒内会发生死锁
4. 系统会自动检测并显示死锁警告

**信号量状态颜色：**
- 绿色（值 > 0）：叉子可用
- 黄色（值 = 0）：叉子被占用
- 红色（值 < 0）：有哲学家在等待

### 4.4 模块4：CPU 调度

**操作步骤：**
1. 添加进程（设置到达时间、执行时间、优先级）
2. 选择调度算法
3. 点击"执行调度"或"动画演示"
4. 查看甘特图和性能指标

**性能指标：**
- 平均等待时间 = Σ(开始时间 - 到达时间) / 进程数
- 平均周转时间 = Σ(完成时间 - 到达时间) / 进程数

### 4.5 模块5：内存管理

#### 动态内存分配

**操作步骤：**
1. 设置总内存大小，点击"初始化"
2. 输入进程名和请求大小
3. 选择分配算法
4. 点击"分配"进行内存分配
5. 选择进程后点击"释放"释放内存

#### 页面置换

**操作步骤：**
1. 设置页框数量
2. 输入页面访问序列（如: 7,0,1,2,0,3,0,4）
3. 选择置换算法
4. 点击"执行"或"动画演示"

**结果说明：**
- H：命中（页面在内存中）
- M：缺失（发生缺页）

### 4.6 模块6：任务管理器

**功能说明：**
- 自动实时刷新系统信息
- 显示 CPU 和内存使用率曲线
- 显示各 CPU 核心负载
- 进程列表支持按 CPU、内存、PID、名称排序
- 刷新间隔可调节（500-5000ms）

**注意：** 需要安装 psutil 才能显示真实系统数据。

---

## 五、常见问题

### Q1: 程序启动报错 "No module named 'PyQt5'"

**解决方法：**
```bash
pip install PyQt5
```

### Q2: 任务管理器显示模拟数据

**原因：** psutil 未安装

**解决方法：**
```bash
pip install psutil
```

### Q3: 如何验证调度算法结果？

手工计算并对比：
1. 画出甘特图
2. 计算每个进程的开始时间、完成时间
3. 计算等待时间 = 开始时间 - 到达时间
4. 计算周转时间 = 完成时间 - 到达时间

### Q4: 页面置换算法对比

| 算法 | 优点 | 缺点 |
|------|------|------|
| FIFO | 实现简单 | 可能淘汰常用页面 |
| LRU | 性能较好 | 实现开销大 |
| OPT | 理论最优 | 需要预知未来访问 |
| CLOCK | 开销小 | 是 LRU 的近似 |

### Q5: 内存碎片如何计算？

外部碎片 = 所有空闲块大小之和

---

## 附录：性能指标公式

| 指标 | 公式 |
|------|------|
| 等待时间 | 开始时间 - 到达时间 |
| 周转时间 | 完成时间 - 到达时间 |
| 命中率 | 命中次数 / 总访问次数 × 100% |
| 缺页率 | 缺页次数 / 总访问次数 × 100% |
| 内存使用率 | 已分配内存 / 总内存 × 100% |

---

*文档版本：v2.2.0*
